name: Build RustDesk Client (Final v3)

on:
  workflow_dispatch:
    inputs:
      config_json:
        description: 'Configuration JSON'
        required: true
        type: string
      executable_name:
        description: 'Executable name'
        required: true
        type: string
        default: 'rustdesk-custom'
      rustdesk_branch:
        description: 'RustDesk branch'
        required: false
        type: string
        default: 'master'
      target_arch:
        description: 'Target architecture'
        required: false
        type: choice
        options:
          - x86_64
          - aarch64
        default: 'x86_64'
      enable_portable:
        description: 'Enable portable mode'
        required: false
        type: boolean
        default: false
      create_installer:
        description: 'Create installer'
        required: false
        type: boolean
        default: true
      enable_debug:
        description: 'Enable debug mode'
        required: false
        type: boolean
        default: false

env:
  RUST_VERSION: 1.75
  LLVM_VERSION: 15.0
  VCPKG_COMMIT_ID: 6f29f12e82a8293156836ad81cc9bf5af41fe836

jobs:
  build-windows:
    name: Build RustDesk for Windows
    runs-on: windows-2022
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Checkout RustDesk
      uses: actions/checkout@v4
      with:
        repository: rustdesk/rustdesk
        ref: ${{ inputs.rustdesk_branch }}
        submodules: recursive
        path: rustdesk
        
    - name: Install LLVM and Clang
      uses: KyleMayes/install-llvm-action@v1
      with:
        version: ${{ env.LLVM_VERSION }}
        
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@v1
      with:
        toolchain: ${{ env.RUST_VERSION }}
        targets: x86_64-pc-windows-msvc
        components:
            -rustfmt
        
    - uses: Swatinem/rust-cache@v2
      with:
        prefix-key: windows-2022
        workspaces: "rustdesk -> target"
        
    - name: Setup vcpkg with Github Actions binary cache
      uses: lukka/run-vcpkg@v11
      with:
        vcpkgDirectory: C:\vcpkg
        vcpkgGitCommitId: ${{ env.VCPKG_COMMIT_ID }}
        doNotCache: false
        
    - name: Install system dependencies
      shell: powershell
      run: |
        Write-Host "=== Installing system dependencies ==="
        choco install nsis -y --no-progress
        Write-Host "[SUCCESS] System dependencies installed"
        
    - name: Setup vcpkg environment
      shell: powershell
      run: |
        Write-Host "=== Setting up vcpkg environment ==="
        
        # Copy our vcpkg.json to rustdesk directory
        Write-Host "Copying vcpkg.json to rustdesk directory..."
        $source = "$env:GITHUB_WORKSPACE\vcpkg.json"
        $dest = "$env:GITHUB_WORKSPACE\rustdesk\vcpkg.json"
        
        if (-not (Test-Path $source)) {
          Write-Host "[ERROR] Source vcpkg.json not found: $source"
          exit 1
        }
        
        Copy-Item $source $dest -Force
        Write-Host "[SUCCESS] vcpkg.json copied successfully"
        
    - name: Install vcpkg dependencies
      shell: powershell
      run: |
        Write-Host "=== Installing vcpkg dependencies ==="
        cd "$env:GITHUB_WORKSPACE\rustdesk"
        
        Write-Host "Current directory: $(Get-Location)"
        Write-Host "vcpkg.json content:"
        Get-Content "vcpkg.json" | Write-Host
        
        Write-Host "Running vcpkg install..."
        & "$env:VCPKG_ROOT\vcpkg.exe" install --triplet x64-windows-static --x-install-root="$env:VCPKG_ROOT\installed"
        
        if ($LASTEXITCODE -ne 0) {
          Write-Host "[ERROR] vcpkg install failed with exit code: $LASTEXITCODE"
          exit 1
        }
        
        Write-Host "[SUCCESS] vcpkg dependencies installed successfully"
        
    - name: Apply configuration
      shell: powershell
      run: |
        Write-Host "=== Applying configuration ==="
        
        cd "$env:GITHUB_WORKSPACE\rustdesk"
        
        # Create config directory
        New-Item -Path "src\ui" -ItemType Directory -Force -ErrorAction SilentlyContinue | Out-Null
        
        # Write config JSON
        '${{ inputs.config_json }}' | Out-File -FilePath "src\ui\config.json" -Encoding UTF8
        
        # Parse configuration
        try {
          $config = '${{ inputs.config_json }}' | ConvertFrom-Json
          
          Write-Host "[DEBUG] Configuration parsed successfully"
          Write-Host "[DEBUG] Server RENDEZVOUS_SERVER: '$($config.server.RENDEZVOUS_SERVER)'"
          Write-Host "[DEBUG] Server RS_PUB_KEY: '$($config.server.RS_PUB_KEY)'"
          Write-Host "[DEBUG] Branding APP_NAME: '$($config.branding.APP_NAME)'"
          Write-Host "[DEBUG] Branding PRODUCT_NAME: '$($config.branding.PRODUCT_NAME)'"
          
        } catch {
          Write-Host "[ERROR] Failed to parse configuration JSON: $($_.Exception.Message)"
          exit 1
        }
        
        # Validate minimum required configuration
        if (-not $config.server.RENDEZVOUS_SERVER) {
          Write-Host "[ERROR] RENDEZVOUS_SERVER is required but not provided"
          exit 1
        }
        
        if (-not $config.server.RS_PUB_KEY) {
          Write-Host "[ERROR] RS_PUB_KEY is required but not provided"
          exit 1
        }
        
        if (-not $config.branding.APP_NAME) {
          Write-Host "[WARNING] APP_NAME not provided, using default 'rustdesk'"
          $config.branding.APP_NAME = "rustdesk"
        }
        
        if (-not $config.branding.PRODUCT_NAME) {
          Write-Host "[WARNING] PRODUCT_NAME not provided, using APP_NAME"
          $config.branding.PRODUCT_NAME = $config.branding.APP_NAME
        }
        
        Write-Host "[SUCCESS] Configuration validation passed - ready for build"
        
        # Create simple Rust config file using separate lines
        $rustConfigLines = @()
        $rustConfigLines += "// Auto-generated configuration"
        $rustConfigLines += "pub const RENDEZVOUS_SERVER: &str = `"$($config.server.RENDEZVOUS_SERVER)`";"
        $rustConfigLines += "pub const RELAY_SERVER: &str = `"$($config.server.RELAY_SERVER)`";"
        $rustConfigLines += "pub const API_SERVER: &str = `"$($config.server.API_SERVER)`";"
        $rustConfigLines += "pub const KEY: &str = `"$($config.server.RS_PUB_KEY)`";"
        $rustConfigLines += "pub const PRODUCT_NAME: &str = `"$($config.branding.PRODUCT_NAME)`";"
        $rustConfigLines += "pub const APP_NAME: &str = `"$($config.branding.APP_NAME)`";"
        
        $rustConfigLines | Out-File -FilePath "src\config.rs" -Encoding UTF8
        Write-Host "[SUCCESS] Rust config created"
        
        # Verify config.rs was created successfully
        if (Test-Path "src\config.rs") {
          $configSize = (Get-Item "src\config.rs").Length
          Write-Host "[SUCCESS] config.rs created (size: $configSize bytes)"
          Write-Host "[DEBUG] config.rs content:"
          Get-Content "src\config.rs" | Write-Host
        } else {
          Write-Host "[ERROR] Failed to create config.rs"
          exit 1
        }
        
        # Update Cargo.toml carefully - only update if different from rustdesk
        if (Test-Path "Cargo.toml") {
          $cargoContent = Get-Content "Cargo.toml" -Raw
          
          if ($config.branding.APP_NAME -ne "rustdesk") {
            # Update package name
            $cargoContent = $cargoContent -replace 'name = "rustdesk"', "name = `"$($config.branding.APP_NAME)`""
            Write-Host "[SUCCESS] Updated package name in Cargo.toml"
            
            # Update default-run target to match new package name
            $cargoContent = $cargoContent -replace 'default-run = "rustdesk"', "default-run = `"$($config.branding.APP_NAME)`""
            Write-Host "[SUCCESS] Updated default-run target in Cargo.toml"
          }
          
          $cargoContent | Out-File -FilePath "Cargo.toml" -Encoding UTF8
        }
        
        Write-Host "[SUCCESS] Configuration applied successfully"
        
      - name: Generate inline module
      shell: powershell
      run: |
        Write-Host "=== Generating inline UI module ==="

        cd "$env:GITHUB_WORKSPACE\rustdesk"

        New-Item -Path "src\ui" -ItemType Directory -Force -ErrorAction SilentlyContinue | Out-Null

        $inlineContent = @"
        // Minimal inline module for compilation
        #[inline]
        pub fn get_index() -> String {
            r#"<html><head><title>RustDesk</title></head><body><h1>RustDesk Client</h1></body></html>"#.to_string()
        }

        #[inline]
        pub fn get_remote() -> String {
            r#"<html><head><title>Remote Control</title></head><body><h1>Remote Control</h1></body></html>"#.to_string()
        }

        #[inline]
        pub fn get_install() -> String {
            r#"<html><head><title>Installation</title></head><body><h1>Installation</h1></body></html>"#.to_string()
        }

        #[inline]
        pub fn get_chatbox() -> String {
            r#"<html><head><title>Chat</title></head><body><h1>Chat</h1></body></html>"#.to_string()
        }

        #[inline]
        pub fn get_cm() -> String {
            r#"<html><head><title>Connection Manager</title></head><body><h1>Connection Manager</h1></body></html>"#.to_string()
        }
        "@
        
        $inlineContent | Out-File -FilePath "src\ui\inline.rs" -Encoding UTF8
        Write-Host "[SUCCESS] Created minimal inline.rs module"
        
        # Verify that inline.rs was created
        if (Test-Path "src\ui\inline.rs") {
          Write-Host "[SUCCESS] inline.rs module verified"
          $inlineSize = (Get-Item "src\ui\inline.rs").Length
          Write-Host "inline.rs size: $inlineSize bytes"
        } else {
          Write-Host "[ERROR] inline.rs module was not created"
          exit 1
        }
        
    - name: Build RustDesk
      shell: powershell
      run: |
        Write-Host "=== Building RustDesk ==="
        
        cd "$env:GITHUB_WORKSPACE\rustdesk"
        
        # Set environment variables for build
        $env:VCPKG_ROOT = "C:\vcpkg"
        $env:VCPKG_DEFAULT_TRIPLET = "x64-windows-static"
        $env:LIBCLANG_PATH = "$env:PROGRAMFILES\LLVM\bin"
        $env:RUSTFLAGS = "-C target-feature=+crt-static"
        $env:RUST_BACKTRACE = "1"
        
        Write-Host "Starting Cargo build..."
        if ("${{ inputs.enable_debug }}" -eq "true") {
          Write-Host "Build mode: Debug"
          cargo build --features inline --verbose
        } else {
          Write-Host "Build mode: Release"
          cargo build --release --features inline --verbose
        }
        
        if ($LASTEXITCODE -ne 0) {
          Write-Host "[ERROR] Build failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
        
        Write-Host "[SUCCESS] Build completed successfully!"
        
    - name: Prepare artifacts
      shell: powershell
      run: |
        Write-Host "=== Preparing artifacts ==="
        
        cd "$env:GITHUB_WORKSPACE\rustdesk"
        
        try {
          $config = '${{ inputs.config_json }}' | ConvertFrom-Json
        } catch {
          Write-Host "[ERROR] Failed to parse config JSON"
          exit 1
        }
        
        $executableName = "${{ inputs.executable_name }}"
        $buildDir = if ("${{ inputs.enable_debug }}" -eq "true") { "target\debug" } else { "target\release" }
        
        Write-Host "Looking for executable in: $buildDir"
        
        # Find the built executable - search in order of likelihood
        $possibleExes = @(
          "$buildDir\$($config.branding.APP_NAME).exe",
          "$buildDir\rustdesk.exe",
          "$buildDir\RustDesk.exe"
        )
        
        # Add fallback: any .exe file in the build directory
        $allExes = Get-ChildItem $buildDir -Filter "*.exe" -ErrorAction SilentlyContinue
        foreach ($exe in $allExes) {
          $fullPath = "$buildDir\$($exe.Name)"
          if ($fullPath -notin $possibleExes) {
            $possibleExes += $fullPath
          }
        }
        
        $builtExecutable = ""
        foreach ($exe in $possibleExes) {
          if (Test-Path $exe) {
            $builtExecutable = $exe
            Write-Host "[SUCCESS] Found executable: $exe"
            break
          }
        }
        
        if (-not $builtExecutable) {
          Write-Host "[ERROR] No executable found. Available files in ${buildDir}:"
          Get-ChildItem $buildDir -Filter "*.exe" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  $($_.Name)" }
          exit 1
        }
        
        # Copy with custom name
        $finalExe = "$buildDir\$executableName.exe"
        if ($builtExecutable -ne $finalExe) {
          Copy-Item $builtExecutable $finalExe -Force
          Write-Host "[SUCCESS] Copied executable to: $finalExe"
        }
        
        # Test the executable quickly to verify it can start
        Write-Host "[TEST] Testing executable startup..."
        try {
          # Try to run with --help to see if it starts
          $testOutput = & $finalExe --help 2>&1 | Out-String
          if ($LASTEXITCODE -eq 0 -or $testOutput -match "rustdesk|RustDesk|help|usage") {
            Write-Host "[SUCCESS] Executable appears to be working (help output received)"
          } else {
            Write-Host "[WARNING] Executable test inconclusive. Exit code: $LASTEXITCODE"
            Write-Host "[WARNING] Output: $testOutput"
          }
        } catch {
          Write-Host "[WARNING] Could not test executable: $($_.Exception.Message)"
        }
        
        # Create installer if requested
        if ("${{ inputs.create_installer }}" -eq "true") {
          Write-Host "Creating installer..."
          
          # Create installer script file
          $installerContent = @(
            "!define PRODUCT_NAME `"$($config.branding.PRODUCT_NAME)`"",
            "!define PRODUCT_VERSION `"1.0.0`"",
            "!define PRODUCT_PUBLISHER `"$($config.branding.PRODUCT_NAME)`"",
            "",
            "SetCompressor lzma",
            "RequestExecutionLevel admin",
            "",
            "Name `"`${PRODUCT_NAME}`"",
            "OutFile `"$executableName-installer.exe`"",
            "InstallDir `"`$PROGRAMFILES\`${PRODUCT_NAME}`"",
            "",
            "Section `"MainSection`" SEC01",
            "  SetOutPath `"`$INSTDIR`"",
            "  File `"$buildDir\$executableName.exe`"",
            "  CreateDirectory `"`$SMPROGRAMS\`${PRODUCT_NAME}`"",
            "  CreateShortCut `"`$SMPROGRAMS\`${PRODUCT_NAME}\`${PRODUCT_NAME}.lnk`" `"`$INSTDIR\$executableName.exe`"",
            "  CreateShortCut `"`$DESKTOP\`${PRODUCT_NAME}.lnk`" `"`$INSTDIR\$executableName.exe`"",
            "  WriteUninstaller `"`$INSTDIR\Uninstall.exe`"",
            "SectionEnd",
            "",
            "Section `"Uninstall`"",
            "  Delete `"`$INSTDIR\$executableName.exe`"",
            "  Delete `"`$INSTDIR\Uninstall.exe`"",
            "  Delete `"`$SMPROGRAMS\`${PRODUCT_NAME}\`${PRODUCT_NAME}.lnk`"",
            "  Delete `"`$DESKTOP\`${PRODUCT_NAME}.lnk`"",
            "  RMDir `"`$SMPROGRAMS\`${PRODUCT_NAME}`"",
            "  RMDir `"`$INSTDIR`"",
            "SectionEnd"
          )
          
          $installerContent | Out-File -FilePath "installer.nsi" -Encoding UTF8
          
          # Compile installer
          & "C:\Program Files (x86)\NSIS\makensis.exe" "installer.nsi"
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "[SUCCESS] Installer created successfully"
          } else {
            Write-Host "⚠️ Installer creation failed, but continuing..."
          }
        }
        
        Write-Host "[SUCCESS] Artifacts prepared successfully"
        
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: rustdesk-client-${{ inputs.executable_name }}
        path: |
          rustdesk/target/debug/*.exe
          rustdesk/target/release/*.exe
          rustdesk/*.exe
        retention-days: 7